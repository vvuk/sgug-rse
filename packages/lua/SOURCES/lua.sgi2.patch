Index: lua-5.3.5/src/luaconf.h
===================================================================
--- lua-5.3.5.orig/src/luaconf.h
+++ lua-5.3.5/src/luaconf.h
@@ -11,6 +11,10 @@
 #include <limits.h>
 #include <stddef.h>
 
+#define LUA_USE_POSIX
+#define LUA_USE_DLOPEN
+#define LUA_USE_READLINE
+#undef LUA_BUILD_AS_DLL
 
 /*
 ** ===================================================================
@@ -200,9 +204,16 @@
 
 #else			/* }{ */
 
-#define LUA_ROOT	"/usr/local/"
+#define LUA_ROOT	"/usr/sgug/"
 #define LUA_LDIR	LUA_ROOT "share/lua/" LUA_VDIR "/"
+#if _MIPS_SIM == _ABIN32
+#define LUA_CDIR	LUA_ROOT "lib32/lua/" LUA_VDIR "/"
+#elif _MIPS_SIM == _ABI64
+#define LUA_CDIR	LUA_ROOT "lib64/lua/" LUA_VDIR "/"
+#else
 #define LUA_CDIR	LUA_ROOT "lib/lua/" LUA_VDIR "/"
+#endif
+
 #define LUA_PATH_DEFAULT  \
 		LUA_LDIR"?.lua;"  LUA_LDIR"?/init.lua;" \
 		LUA_CDIR"?.lua;"  LUA_CDIR"?/init.lua;" \
@@ -496,7 +507,9 @@
 
 #define l_mathop(op)		op
 
-#define lua_str2number(s,p)	strtod((s), (p))
+LUA_API double lua_fixed_strtod(const char *s, char ** p);
+
+#define lua_str2number(s,p)	lua_fixed_strtod((s), (p))
 
 #else						/* }{ */
 
Index: lua-5.3.5/Makefile
===================================================================
--- lua-5.3.5.orig/Makefile
+++ lua-5.3.5/Makefile
@@ -12,9 +12,9 @@ PLAT=posix
 # LUA_ROOT, LUA_LDIR, and LUA_CDIR in luaconf.h.
 INSTALL_TOP= $(INSTALLDIR)
 INSTALL_BIN= $(INSTALL_TOP)/bin
-INSTALL_INC= $(INSTALL_TOP)/include
+INSTALL_INC= $(INSTALL_TOP)/include/lua-$V
 INSTALL_LIB= $(INSTALL_TOP)/$(DIDBS_LIBDIR)
-INSTALL_MAN= $(INSTALL_TOP)/man/man1
+INSTALL_MAN= $(INSTALL_TOP)/share/man/man1
 INSTALL_LMOD= $(INSTALL_TOP)/share/lua/$V
 INSTALL_CMOD= $(INSTALL_TOP)/$(DIDBS_LIBDIR)/lua/$V
 
@@ -36,12 +36,12 @@ RM= rm -f
 # == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======
 
 # Convenience platforms targets.
-PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris
+PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris irix
 
 # What to install.
 TO_BIN= lua luac
 TO_INC= lua.h luaconf.h lualib.h lauxlib.h lua.hpp
-TO_LIB= liblua.a
+TO_LIB= liblua-5.3.so liblua.a
 TO_MAN= lua.1 luac.1
 
 # Lua version and release.
Index: lua-5.3.5/src/Makefile
===================================================================
--- lua-5.3.5.orig/src/Makefile
+++ lua-5.3.5/src/Makefile
@@ -6,9 +6,8 @@
 # Your platform. See PLATS for possible values.
 PLAT= none
 
-CC=$(DIDBS_LUA_CC)
-CFLAGS=$(DIDBS_LUA_CFLAGS) -Wall -Wextra -DLUA_COMPAT_5_2 -DLUA_USE_DLOPEN $(SYSCFLAGS) $(MYCFLAGS)
-LDFLAGS= $(DIDBS_LUA_LDFLAGS) $(SYSLDFLAGS) $(MYLDFLAGS)
+CFLAGS:= $(CFLAGS) -Wall -Wextra -DLUA_COMPAT_5_2 $(SYSCFLAGS) $(MYCFLAGS)
+LDFLAGS:= $(LDFLAGS) $(SYSLDFLAGS) $(MYLDFLAGS)
 LIBS= -lm $(SYSLIBS) $(MYLIBS)
 
 AR= ar rcu
@@ -24,9 +23,11 @@ MYLDFLAGS=
 MYLIBS=
 MYOBJS=
 
+XLIBS=
+
 # == END OF USER SETTINGS -- NO NEED TO CHANGE ANYTHING BELOW THIS LINE =======
 
-PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris
+PLATS= aix bsd c89 freebsd generic linux macosx mingw posix solaris irix
 
 LUA_A=	liblua.a
 CORE_O=	lapi.o lcode.o lctype.o ldebug.o ldo.o ldump.o lfunc.o lgc.o llex.o \
@@ -59,11 +60,15 @@ $(LUA_A): $(BASE_O)
 	$(AR) $@ $(BASE_O)
 	$(RANLIB) $@
 
+liblua.a: $(BASE_O)
+	ar rcu $@ $(BASE_O)
+	ranlib $@
+
 $(LUA_T): $(LUA_O) $(LUA_A)
-	$(CC) -o $@ $(LDFLAGS) $(LUA_O) $(LUA_A) $(LIBS)
+	$(CC) -o $@ $(LDFLAGS) $(LUA_O) $(LUA_A) $(LIBS) $(XLIBS)
 
 $(LUAC_T): $(LUAC_O) $(LUA_A)
-	$(CC) -o $@ $(LDFLAGS) $(LUAC_O) $(LUA_A) $(LIBS)
+	$(CC) -o $@ $(LDFLAGS) $(LUAC_O) $(BASE_O) $(LIBS) $(XLIBS)
 
 clean:
 	$(RM) $(ALL_T) $(ALL_O)
@@ -124,6 +129,9 @@ posix:
 solaris:
 	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_POSIX -DLUA_USE_DLOPEN -D_REENTRANT" SYSLIBS="-ldl"
 
+irix:
+	$(MAKE) $(ALL) liblua.a "LUA_A=liblua-5.3.so" "AR=$(CC) -shared -ldl -o" "RANLIB=touch" SYSLIBS="-ldl" XLIBS="-lreadline -lncurses -ltinfo"
+
 # list targets that do not create files (but not all makes understand .PHONY)
 .PHONY: all $(PLATS) default o a clean depend echo none
 
Index: lua-5.3.5/src/lobject.c
===================================================================
--- lua-5.3.5.orig/src/lobject.c
+++ lua-5.3.5/src/lobject.c
@@ -16,6 +16,9 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <ctype.h>
+#include <limits.h>
+#include <float.h>
 
 #include "lua.h"
 
@@ -520,3 +523,446 @@ void luaO_chunkid (char *out, const char
   }
 }
 
+#ifdef __sgi
+// borrowed from libdicl
+
+#undef MIN
+#undef MAX
+# define LD_STRTOD ld_strtod
+# define LDEXP ldexp
+# define HAVE_UNDERLYING_STRTOD 1
+# define DOUBLE double
+# define MIN DBL_MIN
+# define MAX DBL_MAX
+# define L_(literal) literal
+
+typedef int bool;
+#define false 0
+#define true 1
+
+# define USE_LDEXP 1
+# define HAVE_NL_LANGINFO 1
+
+#define ld_strtol strtol
+#define c_isdigit isdigit
+#define c_isxdigit isxdigit
+#define c_tolower tolower
+#define c_isalnum isalnum
+
+/* Our replacement strtol needs a prototype */
+//extern long int ld_strtol(const char *, char **, int);
+
+/* Return true if C is a space in the current locale, avoiding
+   problems with signed char and isspace.  */
+static bool
+locale_isspace (char c)
+{
+  unsigned char uc = c;
+  return isspace (uc) != 0;
+}
+
+/* Determine the decimal-point character according to the current locale.  */
+static char
+decimal_point_char (void)
+{
+  const char *point;
+  /* Determine it in a multithread-safe way.  We know nl_langinfo is
+     multithread-safe on glibc systems and Mac OS X systems, but is not required
+     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.
+     localeconv() is rarely multithread-safe.  */
+#if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
+  point = nl_langinfo (RADIXCHAR);
+#elif 1
+  char pointbuf[5];
+  sprintf (pointbuf, "%#.0f", 1.0);
+  point = &pointbuf[1];
+#else
+  point = localeconv () -> decimal_point;
+#endif
+  /* The decimal point is always a single byte: either '.' or ','.  */
+  return (point[0] != '\0' ? point[0] : '.');
+}
+
+#if !USE_LDEXP
+ #undef LDEXP
+ #define LDEXP dummy_ldexp
+ /* A dummy definition that will never be invoked.  */
+ static DOUBLE LDEXP (DOUBLE x _GL_UNUSED, int exponent _GL_UNUSED)
+ {
+   abort ();
+   return L_(0.0);
+ }
+#endif
+
+/* Return X * BASE**EXPONENT.  Return an extreme value and set errno
+   to ERANGE if underflow or overflow occurs.  */
+static DOUBLE
+scale_radix_exp (DOUBLE x, int radix, long int exponent)
+{
+  /* If RADIX == 10, this code is neither precise nor fast; it is
+     merely a straightforward and relatively portable approximation.
+     If N == 2, this code is precise on a radix-2 implementation,
+     albeit perhaps not fast if ldexp is not in libc.  */
+
+  long int e = exponent;
+
+  if (USE_LDEXP && radix == 2)
+    return LDEXP (x, e < INT_MIN ? INT_MIN : INT_MAX < e ? INT_MAX : e);
+  else
+    {
+      DOUBLE r = x;
+
+      if (r != 0)
+        {
+          if (e < 0)
+            {
+              while (e++ != 0)
+                {
+                  r /= radix;
+                  if (r == 0 && x != 0)
+                    {
+                      errno = ERANGE;
+                      break;
+                    }
+                }
+            }
+          else
+            {
+              while (e-- != 0)
+                {
+                  if (r < -MAX / radix)
+                    {
+                      errno = ERANGE;
+                      return -HUGE_VAL;
+                    }
+                  else if (MAX / radix < r)
+                    {
+                      errno = ERANGE;
+                      return HUGE_VAL;
+                    }
+                  else
+                    r *= radix;
+                }
+            }
+        }
+
+      return r;
+    }
+}
+
+/* Parse a number at NPTR; this is a bit like strtol (NPTR, ENDPTR)
+   except there are no leading spaces or signs or "0x", and ENDPTR is
+   nonnull.  The number uses a base BASE (either 10 or 16) fraction, a
+   radix RADIX (either 10 or 2) exponent, and exponent character
+   EXPCHAR.  BASE is RADIX**RADIX_MULTIPLIER.  */
+static DOUBLE
+parse_number (const char *nptr,
+              int base, int radix, int radix_multiplier, char radixchar,
+              char expchar,
+              char **endptr)
+{
+  const char *s = nptr;
+  const char *digits_start;
+  const char *digits_end;
+  const char *radixchar_ptr;
+  long int exponent;
+  DOUBLE num;
+
+  /* First, determine the start and end of the digit sequence.  */
+  digits_start = s;
+  radixchar_ptr = NULL;
+  for (;; ++s)
+    {
+      if (base == 16 ? c_isxdigit (*s) : c_isdigit (*s))
+        ;
+      else if (radixchar_ptr == NULL && *s == radixchar)
+        {
+          /* Record that we have found the decimal point.  */
+          radixchar_ptr = s;
+        }
+      else
+        /* Any other character terminates the digit sequence.  */
+        break;
+    }
+  digits_end = s;
+  /* Now radixchar_ptr == NULL or
+     digits_start <= radixchar_ptr < digits_end.  */
+
+  if (false)
+    { /* Unoptimized.  */
+      exponent =
+        (radixchar_ptr != NULL
+         ? - (long int) (digits_end - radixchar_ptr - 1)
+         : 0);
+    }
+  else
+    { /* Remove trailing zero digits.  This reduces rounding errors for
+         inputs such as 1.0000000000 or 10000000000e-10.  */
+      while (digits_end > digits_start)
+        {
+          if (digits_end - 1 == radixchar_ptr || *(digits_end - 1) == '0')
+            digits_end--;
+          else
+            break;
+        }
+      exponent =
+        (radixchar_ptr != NULL
+         ? (digits_end > radixchar_ptr
+            ? - (long int) (digits_end - radixchar_ptr - 1)
+            : (long int) (radixchar_ptr - digits_end))
+         : (long int) (s - digits_end));
+    }
+
+  /* Then, convert the digit sequence to a number.  */
+  {
+    const char *dp;
+    num = 0;
+    for (dp = digits_start; dp < digits_end; dp++)
+      if (dp != radixchar_ptr)
+        {
+          int digit;
+
+          /* Make sure that multiplication by BASE will not overflow.  */
+          if (!(num <= MAX / base))
+            {
+              /* The value of the digit and all subsequent digits don't matter,
+                 since we have already gotten as many digits as can be
+                 represented in a 'DOUBLE'.  This doesn't necessarily mean that
+                 the result will overflow: The exponent may reduce it to within
+                 range.  */
+              exponent +=
+                (digits_end - dp)
+                - (radixchar_ptr >= dp && radixchar_ptr < digits_end ? 1 : 0);
+              break;
+            }
+
+          /* Eat the next digit.  */
+          if (c_isdigit (*dp))
+            digit = *dp - '0';
+          else if (base == 16 && c_isxdigit (*dp))
+            digit = c_tolower (*dp) - ('a' - 10);
+          else
+            abort ();
+          num = num * base + digit;
+        }
+  }
+
+  exponent = exponent * radix_multiplier;
+
+  /* Finally, parse the exponent.  */
+  if (c_tolower (*s) == expchar && ! locale_isspace (s[1]))
+    {
+      /* Add any given exponent to the implicit one.  */
+      int saved_errno = errno;
+      char *end;
+
+      long int value = ld_strtol (s + 1, &end, 10);
+
+      errno = saved_errno;
+
+      if (s + 1 != end)
+        {
+          /* Skip past the exponent, and add in the implicit exponent,
+             resulting in an extreme value on overflow.  */
+          s = end;
+          exponent =
+            (exponent < 0
+             ? (value < LONG_MIN - exponent ? LONG_MIN : exponent + value)
+             : (LONG_MAX - exponent < value ? LONG_MAX : exponent + value));
+        }
+    }
+
+  *endptr = (char *) s;
+  return scale_radix_exp (num, radix, exponent);
+}
+
+/* HP cc on HP-UX 10.20 has a bug with the constant expression -0.0.
+   ICC 10.0 has a bug when optimizing the expression -zero.
+   The expression -MIN * MIN does not work when cross-compiling
+   to PowerPC on Mac OS X 10.5.  */
+static DOUBLE
+minus_zero (void)
+{
+#if defined __hpux || defined __sgi || defined __ICC
+  return -MIN * MIN;
+#else
+  return -0.0;
+#endif
+}
+
+/* Convert NPTR to a DOUBLE.  If ENDPTR is not NULL, a pointer to the
+   character after the last one used in the number is put in *ENDPTR.  */
+static DOUBLE
+LD_STRTOD (const char *nptr, char **endptr)
+# undef LD_STRTOD
+# define LD_STRTOD(NPTR,ENDPTR) \
+   parse_number (NPTR, 10, 10, 1, radixchar, 'e', ENDPTR)
+/* From here on, STRTOD refers to the underlying implementation.  It needs
+   to handle only finite unsigned decimal numbers with non-null ENDPTR.  */
+{
+  char radixchar;
+  bool negative = false;
+
+  /* The number so far.  */
+  DOUBLE num;
+
+  const char *s = nptr;
+  const char *end;
+  char *endbuf;
+  int saved_errno = errno;
+
+  radixchar = decimal_point_char ();
+
+  /* Eat whitespace.  */
+  while (locale_isspace (*s))
+    ++s;
+
+  /* Get the sign.  */
+  negative = *s == '-';
+  if (*s == '-' || *s == '+')
+    ++s;
+
+  num = LD_STRTOD (s, &endbuf);
+  end = endbuf;
+
+  if (c_isdigit (s[*s == radixchar]))
+    {
+      /* If a hex float was converted incorrectly, do it ourselves.
+         If the string starts with "0x" but does not contain digits,
+         consume the "0" ourselves.  If a hex float is followed by a
+         'p' but no exponent, then adjust the end pointer.  */
+      if (*s == '0' && c_tolower (s[1]) == 'x')
+        {
+          if (! c_isxdigit (s[2 + (s[2] == radixchar)]))
+            {
+              end = s + 1;
+
+              /* strtod() on z/OS returns ERANGE for "0x".  */
+              errno = saved_errno;
+            }
+          else if (end <= s + 2)
+            {
+              num = parse_number (s + 2, 16, 2, 4, radixchar, 'p', &endbuf);
+              end = endbuf;
+            }
+          else
+            {
+              const char *p = s + 2;
+              while (p < end && c_tolower (*p) != 'p')
+                p++;
+              if (p < end && ! c_isdigit (p[1 + (p[1] == '-' || p[1] == '+')]))
+                {
+                  char *dup = strdup (s);
+                  errno = saved_errno;
+                  if (!dup)
+                    {
+                      /* Not really our day, is it.  Rounding errors are
+                         better than outright failure.  */
+                      num =
+                        parse_number (s + 2, 16, 2, 4, radixchar, 'p', &endbuf);
+                    }
+                  else
+                    {
+                      dup[p - s] = '\0';
+                      num = LD_STRTOD (dup, &endbuf);
+                      saved_errno = errno;
+                      free (dup);
+                      errno = saved_errno;
+                    }
+                  end = p;
+                }
+            }
+        }
+      else
+        {
+          /* If "1e 1" was misparsed as 10.0 instead of 1.0, re-do the
+             underlying STRTOD on a copy of the original string
+             truncated to avoid the bug.  */
+          const char *e = s + 1;
+          while (e < end && c_tolower (*e) != 'e')
+            e++;
+          if (e < end && ! c_isdigit (e[1 + (e[1] == '-' || e[1] == '+')]))
+            {
+              char *dup = strdup (s);
+              errno = saved_errno;
+              if (!dup)
+                {
+                  /* Not really our day, is it.  Rounding errors are
+                     better than outright failure.  */
+                  num = parse_number (s, 10, 10, 1, radixchar, 'e', &endbuf);
+                }
+              else
+                {
+                  dup[e - s] = '\0';
+                  num = LD_STRTOD (dup, &endbuf);
+                  saved_errno = errno;
+                  free (dup);
+                  errno = saved_errno;
+                }
+              end = e;
+            }
+        }
+
+      s = end;
+    }
+
+  /* Check for infinities and NaNs.  */
+  else if (c_tolower (*s) == 'i'
+           && c_tolower (s[1]) == 'n'
+           && c_tolower (s[2]) == 'f')
+    {
+      s += 3;
+      if (c_tolower (*s) == 'i'
+          && c_tolower (s[1]) == 'n'
+          && c_tolower (s[2]) == 'i'
+          && c_tolower (s[3]) == 't'
+          && c_tolower (s[4]) == 'y')
+        s += 5;
+      num = HUGE_VAL;
+      errno = saved_errno;
+    }
+  else if (c_tolower (*s) == 'n'
+           && c_tolower (s[1]) == 'a'
+           && c_tolower (s[2]) == 'n')
+    {
+      s += 3;
+      if (*s == '(')
+        {
+          const char *p = s + 1;
+          while (c_isalnum (*p))
+            p++;
+          if (*p == ')')
+            s = p + 1;
+        }
+
+      /* If the underlying implementation misparsed the NaN, assume
+         its result is incorrect, and return a NaN.  Normally it's
+         better to use the underlying implementation's result, since a
+         nice implementation populates the bits of the NaN according
+         to interpreting n-char-sequence as a hexadecimal number.  */
+      if (s != end || num == num)
+        num = NAN;
+      errno = saved_errno;
+    }
+  else
+    {
+      /* No conversion could be performed.  */
+      errno = EINVAL;
+      s = nptr;
+    }
+
+  if (endptr != NULL)
+    *endptr = (char *) s;
+  /* Special case -0.0, since at least ICC miscompiles negation.  We
+     can't use copysign(), as that drags in -lm on some platforms.  */
+  if (!num && negative)
+    return minus_zero ();
+  return negative ? -num : num;
+}
+
+double lua_fixed_strtod (const char *s, char ** p) {
+  return ld_strtod(s, p);
+}
+#endif
+
+
